#! perl

use Data::Dumper;

use X11::Protocol 0.56;
use X11::Protocol::Constants qw/ Shift Mod5 ShiftMask /;
use X11::Protocol::WM 29;
use X11::Keysyms '%keysymtocode', 'MISCELLANY', 'XKB_KEYS', '3270', 'LATIN1',
    'LATIN2', 'LATIN3', 'LATIN4', 'KATAKANA', 'ARABIC', 'CYRILLIC', 'GREEK',
    'TECHNICAL', 'SPECIAL', 'PUBLISHING', 'APL', 'HEBREW', 'THAI', 'KOREAN';
use Symbol qw/ gensym /;

my %windows;    # hash for all window definitions
my %menus;      # hash for all menu definitions

my $X;
my %keyboardmap;
use AnyEvent::I3 qw(:all);
 
my $i3 = i3();

my $em;


my $wid;
$|=1;

sub is_candidate($) {
	my $node = shift;
}

sub is_us($) {
	my %node = %{$_[0]};
	return ($node{'window'} == $wid);
}

sub parse_node($$) {
	my %node = %{$_[0]};
	my $receivers = $_[1];
	print($node{'window_properties'}{'instance'}," ", $node{'window_properties'}{'class'},"\n");
	foreach my $child (@{$node{'nodes'}}) {
		parse_node($child, \$receivers);
	};
	printf("endpoint found: %s\n", $node{'window_properties'}{'instance'});
	print(is_us(\%node));
}

sub i3_recv_tree {
	my %tree = %{$_[0]->recv};
	my $new_receivers=[];
	parse_node(\%tree, \$new_receivers);

	#	print Dumper(\$tree);

}

sub i3_recv_workspaces {
	$i3->get_tree->cb(\&i3_recv_tree);

	#my $workspaces = $_[0]->recv;

}

sub on_start {
	#	print Dumper \@_;
	$X = X11::Protocol->new();
	my($self)=@_;
	$wid = $self->parent;

	$em = $X->pack_event_mask('KeyPress', 'KeyRelease');

	my $cv = $i3->connect;
	$cv->cb (sub {
		#print("I3 connected", Dumper($_[0]->recv, $cv, $i3));
		#my $workspaces = $i3->message(TYPE_GET_WORKSPACES);
		#$workspaces->cb(\&i3_recv_workspaces);
		$i3->subscribe({'workspace'=>\&i3_recv_workspaces});
		$i3->subscribe({'window'=>\&i3_recv_workspaces});

		});
	#$workspaces->send;
#	$cv->send;

    if ( !$X ) {
        die("Failed to get X connection\n");
    }

	return ();
}

sub send_event {
	my $tgtevt=shift;
	my $event_string = $X->pack_event(%$tgtevt);

	#print Dumper \$tgtevt;
	#ljlj
	#print $X->SendEvent( 0x600041, 0, $em, $event_string);
	$X->flush();
	return 1;
}

my $s=0;
sub on_key_release {
	my ($term, $event, $keysym, $octets) = @_;
	my %tgtevt;

	$tgtevt{'name'} = 'KeyRelease';
	$tgtevt{'event'} = 0x2002629;
	$tgtevt{'detail'} = %$event{'keycode'};
	$tgtevt{'state'} = %$event{'state'};
	$tgtevt{'code'} = 2;#%$event{'type'};
	$tgtevt{'event_x'} = %$event{'x'};
	$tgtevt{'event_y'} = %$event{'y'};
	$tgtevt{'same_screen'} = 1,
	$tgtevt{'root'} = $X->{'root'};
	$tgtevt{'child'}        = 'None';
	$tgtevt{'time'} = time();
	$tgtevt{'root_x'} = %$event{'x_root'};
	$tgtevt{'root_y'} = %$event{'y_root'};
	$s+=1;
	$tgtevt{'sequence_number'} = $s;

	#send_event(\%tgtevt);

}
sub on_key_press {
	my ($term, $event, $keysym, $octets) = @_;
	my %tgtevt;

	$tgtevt{'name'} = 'KeyPress';
	$tgtevt{'event'} = 0x600041;
	$tgtevt{'detail'} = %$event{'keycode'};
	$tgtevt{'state'} = %$event{'state'};
	$tgtevt{'code'} = 2;#%$event{'type'};
	$tgtevt{'event_x'} = %$event{'x'};
	$tgtevt{'event_y'} = %$event{'y'};
	$tgtevt{'same_screen'} = 1,
	$tgtevt{'root'} = $X->{'root'};
	$tgtevt{'child'}        = 'None';
	$tgtevt{'time'} = time();
	$tgtevt{'root_x'} = %$event{'x_root'};
	$tgtevt{'root_y'} = %$event{'y_root'};
	$s+=1;
	$tgtevt{'sequence_number'} = $s;
	#$tgtevt{'sequence_number'} = %$event{'serial'};

	send_event(\%tgtevt);

    return 1;
}
